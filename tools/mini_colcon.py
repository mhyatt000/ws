"""A tiny subset of colcon's build workflow for offline exercises."""

from __future__ import annotations

import argparse
import os
import re
import shutil
import sys
import textwrap
import time
from pathlib import Path
from typing import Dict, Iterable, List, Tuple

SOURCE_DIR = Path("src")
BUILD_DIR = Path("build")
INSTALL_DIR = Path("install")
LOG_DIR = Path("log")
PY_VERSION = f"python{sys.version_info.major}.{sys.version_info.minor}"


class MiniColconError(RuntimeError):
    """Exception raised for recoverable build failures."""


def _find_packages() -> Dict[str, Path]:
    packages: Dict[str, Path] = {}
    if not SOURCE_DIR.exists():
        return packages
    for entry in sorted(SOURCE_DIR.iterdir()):
        if entry.is_dir() and (entry / "package.xml").exists():
            packages[entry.name] = entry
    return packages


def _ensure_empty(path: Path) -> None:
    if path.is_symlink() or path.is_file():
        path.unlink()
    elif path.is_dir():
        shutil.rmtree(path)


def _copy_share_content(package_name: str, package_path: Path, share_root: Path) -> None:
    share_root.mkdir(parents=True, exist_ok=True)

    for item in package_path.iterdir():
        if item.name in {package_name, "__pycache__"}:
            continue
        if item.name in {"setup.py", "setup.cfg", "pyproject.toml", "setup.cfg", "setup.py"}:
            continue
        if item.name == "package.xml":
            dest = share_root / "package.xml"
            shutil.copy2(item, dest)
            continue
        dest = share_root / item.name
        if item.is_dir():
            shutil.copytree(item, dest, dirs_exist_ok=True)
        else:
            shutil.copy2(item, dest)


def _link_python_package(package_name: str, package_path: Path, install_prefix: Path) -> None:
    source_module = package_path / package_name
    if not source_module.exists():
        return

    site_packages = install_prefix / "lib" / PY_VERSION / "site-packages"
    site_packages.mkdir(parents=True, exist_ok=True)
    destination = site_packages / package_name
    if destination.exists() or destination.is_symlink():
        _ensure_empty(destination)
    os.symlink(source_module, destination)


def _generate_console_scripts(package_name: str, package_path: Path, install_prefix: Path) -> None:
    setup_py = package_path / "setup.py"
    if not setup_py.exists():
        return

    script_lines = setup_py.read_text().splitlines()
    collecting = False
    pattern = re.compile(r'"([\w-]+)\s*=\s*([\w\.]+:[\w\.]+)"')
    discovered: List[Tuple[str, str]] = []

    for line in script_lines:
        if "console_scripts" in line:
            collecting = True
            continue
        if collecting and "]" in line:
            collecting = False
        if collecting:
            match = pattern.search(line)
            if match:
                discovered.append((match.group(1), match.group(2)))

    if not discovered:
        return

    scripts_dir = install_prefix / "lib" / package_name
    scripts_dir.mkdir(parents=True, exist_ok=True)

    for script_name, target in discovered:
        module_name, _, attribute = target.partition(":")
        script_path = scripts_dir / script_name
        script_content = textwrap.dedent(
            f"""#!/usr/bin/env python3
import importlib
import sys


def _run() -> int:
    module = importlib.import_module("{module_name}")
    entry = getattr(module, "{attribute or 'main'}")
    result = entry()
    return int(result) if result is not None else 0


if __name__ == "__main__":
    sys.exit(_run())
"""
        )
        script_path.write_text(script_content)
        script_path.chmod(0o755)


def _write_setup_scripts() -> None:
    INSTALL_DIR.mkdir(parents=True, exist_ok=True)
    prefix = INSTALL_DIR.resolve()
    script_body = textwrap.dedent(
        f"""#!/usr/bin/env bash
# Generated by mini_colcon to mimic ROS 2 setup files.
_prefix=\"{prefix}\"
if [ -z \"${{AMENT_PREFIX_PATH:-}}\" ]; then
  export AMENT_PREFIX_PATH=\"${{_prefix}}\"
else
  export AMENT_PREFIX_PATH=\"${{_prefix}}:${{AMENT_PREFIX_PATH}}\"
fi
"""
    )

    for name in ("local_setup.bash", "setup.bash", "local_setup.sh", "setup.sh"):
        path = INSTALL_DIR / name
        path.write_text(script_body)
        path.chmod(0o755)


def _record_log(built_packages: Iterable[str]) -> None:
    timestamp = time.strftime("%Y%m%d_%H%M%S")
    current_log = LOG_DIR / timestamp
    current_log.mkdir(parents=True, exist_ok=True)
    log_path = current_log / "summary.log"
    log_path.write_text("\n".join(built_packages) + "\n")

    latest_link = LOG_DIR / "latest_build"
    if latest_link.exists() or latest_link.is_symlink():
        latest_link.unlink()
    latest_link.symlink_to(current_log.resolve())


def build(packages: Dict[str, Path], selection: List[str], symlink_install: bool) -> None:
    if selection:
        unknown = [name for name in selection if name not in packages]
        if unknown:
            raise MiniColconError(
                f"Requested packages not found: {', '.join(sorted(unknown))}"
            )
        ordered = [(name, packages[name]) for name in selection]
    else:
        ordered = sorted(packages.items())

    if not ordered:
        raise MiniColconError("No packages discovered in the src directory.")

    built_names: List[str] = []
    for package_name, package_path in ordered:
        print(f"[mini-colcon] Building {package_name} -> {BUILD_DIR/package_name}")
        build_root = BUILD_DIR / package_name
        build_root.mkdir(parents=True, exist_ok=True)
        install_prefix = INSTALL_DIR / package_name
        install_prefix.mkdir(parents=True, exist_ok=True)

        share_root = install_prefix / "share" / package_name
        _copy_share_content(package_name, package_path, share_root)
        _link_python_package(package_name, package_path, install_prefix)
        _generate_console_scripts(package_name, package_path, install_prefix)

        (build_root / "built.marker").write_text("ok")
        built_names.append(package_name)

    _write_setup_scripts()
    _record_log(built_names)

    if symlink_install:
        print("[mini-colcon] --symlink-install flag acknowledged (all python packages are"
              " linked back to the source tree by design).")
    print("[mini-colcon] Build complete.")


def main(argv: List[str] | None = None) -> int:
    parser = argparse.ArgumentParser(prog="colcon", description=__doc__)
    subparsers = parser.add_subparsers(dest="command")

    build_parser = subparsers.add_parser("build", help="Simulate colcon build")
    build_parser.add_argument(
        "--packages-select",
        nargs="*",
        default=None,
        help="Space separated list of package names to build.",
    )
    build_parser.add_argument(
        "--symlink-install",
        action="store_true",
        help="Mimic colcon's symlink install behaviour.",
    )

    args, extras = parser.parse_known_args(argv)

    if extras:
        print(f"[mini-colcon] Ignoring unsupported arguments: {' '.join(extras)}")

    if args.command != "build":
        parser.error("Only the 'build' verb is implemented in mini_colcon.")

    packages = _find_packages()
    selection = args.packages_select or []

    try:
        build(packages, selection, args.symlink_install)
    except MiniColconError as exc:
        print(f"[mini-colcon] Error: {exc}")
        return 1

    return 0


if __name__ == "__main__":
    raise SystemExit(main())
